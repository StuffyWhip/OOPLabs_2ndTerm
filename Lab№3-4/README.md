## Lab #3-4 -- "Разработка STL-подобных контейнеров, итераторов и алгоритмов"
## Часть 1. Разработка контейнерных классов
Вариант 1
Разработать шаблонный класс Vector для динамического хранения одномерного массива данных. Данный класс должен обеспечивать хранение данных любого типа _DataType (включая пользовательские) и реализовывать следующие методы:

Конструкторы:
- Конструктор по умолчанию.
- Конструктор, принимающий количество элементов (создает вектор с помощью конструкторов по умолчанию для элементов).
- Конструктор, принимающий количество элементов и значение, инициализирующее элементы вектора.
- Конструктор, принимающий интервал [beg,end), заданный итераторами.
- Конструктор, принимающий список инициализации std::initializer_list.
- Копирующий конструктор.
- Конструктор переноса.
- Деструктор.

Функции-операции:
- Операция присваивания с копированием.
- Операция присваивания с переносом.
- Операции индексирования (для чтения и записи), возвращающие ссылку на соответствующий элемент (без проверки выхода за пределы массива).

Методы:
- at(idx) – возвращает элемент с индексом idx (при выходе за пределы допустимого диапазона генерирует исключение).
- begin() – возвращает итератор на начало вектора.
- end() – возвращает итератор на элемент, следующий за последним.
- pushBack(elem) – добавляет копию аргумента elem в конец вектора. Предоставить обычную версию и версию с переносом.
- popBack() – удаляет последний элемент.
- insert(pos,elem) – вставляет копию элемента elem перед позицией итератора pos и возвращает позицию нового элемента. 
- Предоставить обычную версию и версию с переносом.
- insert(pos,beg,end) – вставляет копии всех элементов интервала [beg,end) перед позицией итератора pos и возвращает позицию первого нового элемента (или итератор pos, если новых элементов нет).
- erase(pos) – удаляет элемент в позиции итератора pos и возвращает позицию следующего элемента.
- reserve(num) – увеличивает емкость (объем зарезервированной памяти).
- resize(num) – изменяет количество элементов до num (если размер size() увеличивается, новые элементы создаются конструкторами по умолчанию для элементов).
- empty() – возвращает результат проверки того, что контейнер пуст.
- size() – возвращает размер вектора.
- capacity() – возвращает количество элементов, максимально возможное без повторного выделения памяти.
- clear() – удаляет все элементы вектора.

## Основные требования для класса Vector
1) Длина вектора должна динамически изменяться каждый раз, когда фактический размер вектора, возвращаемый методом size(), превышает размер зарезервированной памяти capacity(). В этом 
случае необходимо вновь выделить память в размере 2 * capacity() 
(см. рис. 2). 

![image](https://github.com/user-attachments/assets/9159c0a4-d14c-4487-8402-26478daed7f6)


2) Предусмотреть генерацию и обработку возможных исключительных 
ситуаций.

## Часть 2. Разработка итераторов
Вариант 1

Разработать шаблонный класс итератора VectorIterator, предназначенный для обхода элементов контейнера Vector. Данный класс является оберткой для обычного указателя. VectorIterator должен иметь методы, перечисленные ниже:

Конструкторы:

- Конструктор, принимающий ссылку на контейнер Vector и указатель на текущий элемент или индекс текущего элемента.
- Копирующий конструктор.
- Деструктор.

Функции-операции:

- ++, -- (префиксные и постфиксные).
- * (разыменование).
- = (присваивание).
- +, - (сложение и вычитание с целым числом).
- ==, !=, <, <=, >, >= (сравнение итераторов).
- +=, -= (перемещение итератора на n элементов вперед и назад соответственно)
- -> (оператор доступа).
- [] (обеспечивает доступ к элементу с индексом n).
- Операция приведения типа.
  
## Основные требования для класса VectorIterator
Внутри класса Vector должно быть public-переименование:

- using iterator = VectorIterator;
- Тип iterator должен использоваться для доступа к элементам контейнера через итераторы совместно с функциями begin() и end(), например:
  Vector<int>::iterator iter = vec.begin();
- Предусмотреть обработку возможных исключительных ситуаций.

## Часть 3. Разработка алгоритмов
В отдельном файле Algorithm.h разработать следующие алгоритмы на базе шаблонных функций:
- Алгоритм findIf(beg,end,pred) для поиска по диапазону [beg,end) произвольного контейнера при заданном условии. Возвращает итератор на найденный элемент или итератор на элемент, следующий за последним, в противном случае.
- Алгоритм minElement(beg,end) для определения минимального элемента в диапазоне [beg,end) произвольного контейнера. Возвращает итератор на найденный элемент или итератор на элемент, следующий за последним, в противном случае.
- Алгоритм maxElement(beg,end) для определения максимального элемента в произвольном контейнере. Возвращает итератор на найденный элемент или итератор на элемент, следующий за последним, в противном случае.
- Алгоритм forEach(beg,end,op) для выполнения произвольной операции над элементами диапазона [beg,end) произвольного контейнера. Ничего не возвращает.
- Алгоритм сортировки Sort(beg,end)  заданного диапазона [beg,end) произвольного контейнера (метод сортировки выбрать самостоятельно). Ничего не возвращает.
- Алгоритм copyIf(sourceBeg, sourceEnd, destBeg, pred) для копирования элементов диапазона [sourceBeg,sourceEnd) произвольного контейнера-источника в контейнер-приемник, начиная с позиции итератора destBeg, удовлетворяющих предикату pred.
## Основные требования по алгоритмам:
Алгоритмы должны быть построены таким образом, чтобы они взаимодействовали с контейнерами только посредством итераторов. 

Передача контейнеров в алгоритмы не допускается.

Логические условия ряда алгоритмов (например, условие отбора нужного элемента при поиске, копировании и т.д.) должны быть реализованы в виде предикатов (на базе функторов или лямбда-функций).
